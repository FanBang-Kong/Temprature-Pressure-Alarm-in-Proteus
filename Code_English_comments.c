/* Main.ino file generated by New Project wizard
 *
 * Created:   周三 12月 3 2025
 * Processor: Arduino Uno
 * Compiler:  Arduino AVR (Proteus)
 */

// Peripheral Configuration Code (do not edit)
//---CONFIG_BEGIN---
#pragma GCC push_options
#pragma GCC optimize ("Os")

#include <Core.h> // Required by cpu
#include <cpu.h>

#pragma GCC pop_options

// Peripheral Constructors
CPU &cpu = Cpu;

void peripheral_setup () {
}

void peripheral_loop() {
}
//---CONFIG_END---

#pragma GCC push_options
#pragma GCC optimize ("O1")







//KONG
#include <Wire.h>
#include <avr/pgmspace.h>

// ======= Pressure system IO =========
const int pressurePin   = A3;
const int pGreenLED     = 5;
const int pYellowLED    = 6; 
const int pRedBuzzerLED = 7;

const float P_LOW_BAR   = 37.0;
const float P_HIGH_BAR  = 42.5;


float currentPressure   = 0.0;
float lastPressure      = 0.0;
const char* pTrendStr   = "ST";   // trend UP / DN / ST

volatile bool pressureCheckFlag = false;


// ========== Emergency Hardware Interrupt (INT0 on D2) =========
const int emergencyPin = 2;   // LM393 DO output → Arduino D2
volatile bool emergencyTriggered = false;


//TAN
const int yellowLED = 8;
const int greenLED = 9;
const int redLED = 10;
const int LM35 = A0;
const int greenYellowBoundary = A1;
const int yellowRedBoundary = A2;

float currentTemperature;
float setLowTemperature;
float setHighTemperature;

float lastTemperature = 0.0;
const char* trendStr = "ST"; 
bool alarmBlink = false; 
unsigned long lastBlinkMs = 0;

//Auto return timer （only for setting）
unsigned long settingsEnterMs = 0;
unsigned long lastCountdownDrawMs = 0;
const unsigned long SETTINGS_TIMEOUT_MS = 2000;

//KONG
// ===== OLED Menu System (Home / Settings) =====
enum Screen {
  SCREEN_MAIN_MENU = 0,
  SCREEN_HOME,
  SCREEN_SETTINGS
};

Screen currentScreen = SCREEN_MAIN_MENU; 
int currentMenuIndex = 0;                  //0=HOME, 1=SETTINGS

// Button：D3 = UP/MOVE, D4 = BACK/ENTER
const int buttonUpPin   = 3;
const int buttonBackPin = 4;

// debounce
const unsigned long debounceDelay = 30;
bool buttonUpState           = HIGH;
bool buttonBackState         = HIGH;
bool lastButtonUpReading     = HIGH;
bool lastButtonBackReading   = HIGH;
unsigned long lastButtonUpDebounceTime   = 0;
unsigned long lastButtonBackDebounceTime = 0;


#define BACK_HINT_X 12
#define BACK_HINT_Y 3



//KONG       
//OLED basic part
#define OLED_ADDR 0x3C
#define OLED_WIDTH 128
#define OLED_HEIGHT 32
#define OLED_PAGES (OLED_HEIGHT / 8)

void oledSendCommand(uint8_t cmd) {
  Wire.beginTransmission(OLED_ADDR);
  Wire.write(0x00);   // 0x00 = following bytes are commands
  Wire.write(cmd);
  Wire.endTransmission();
}

void oledSendData(uint8_t data) {
  Wire.beginTransmission(OLED_ADDR);
  Wire.write(0x40);   // 0x40 = subsequent bytes are display data
  Wire.write(data);
  Wire.endTransmission();
}

void oledSendDataBuffer(const uint8_t* buf, uint16_t len) {
  while (len--) {
    Wire.beginTransmission(OLED_ADDR);
    Wire.write(0x40);
    Wire.write(*buf++);
    Wire.endTransmission();
  }
}

// Initialize 128x32 SSD1306 (I2C)
void oledInit() {
  Wire.begin();
  delay(50);
  
  oledSendCommand(0xAE);

  oledSendCommand(0xD5);
  oledSendCommand(0x80);

  oledSendCommand(0xA8);
  oledSendCommand(0x1F);

  oledSendCommand(0xD3);
  oledSendCommand(0x00);

  oledSendCommand(0x40); 

  oledSendCommand(0x8D);
  oledSendCommand(0x14);

  oledSendCommand(0x20);
  oledSendCommand(0x00); 

  oledSendCommand(0xA1); 
  oledSendCommand(0xC8);

  oledSendCommand(0xDA);
  oledSendCommand(0x02);

  oledSendCommand(0x81);
  oledSendCommand(0x8F);

  oledSendCommand(0xD9);
  oledSendCommand(0xF1);

  oledSendCommand(0xDB);
  oledSendCommand(0x40);

  oledSendCommand(0xA4);
  oledSendCommand(0xA6);

  oledSendCommand(0x2E);
  oledSendCommand(0xAF);
}

// Clear OLED display
void oledClear() {
  for (uint8_t page = 0; page < OLED_PAGES; page++) {
    oledSendCommand(0xB0 | page);
    oledSendCommand(0x00);
    oledSendCommand(0x10);

    for (uint8_t col = 0; col < OLED_WIDTH; col++) {
      oledSendData(0x00);
    }
  }
}

// Set cursor position (in characters, x: 0–15, y: 0–3)
void oledSetCursor(uint8_t xChar, uint8_t yPage) {
  uint8_t col = xChar * 6;
  if (col >= OLED_WIDTH) col = 0;
  if (yPage >= OLED_PAGES) yPage = 0;

  oledSendCommand(0xB0 | yPage);
  oledSendCommand(0x00 | (col & 0x0F));
  oledSendCommand(0x10 | ((col >> 4) & 0x0F));
}

//  A very simple 5x7 font: digits and uppercase letters only
const uint8_t FONT5x7[][5] PROGMEM = {
  {0x00,0x00,0x00,0x00,0x00}, // ' '
  {0x3E,0x51,0x49,0x45,0x3E}, // '0'
  {0x00,0x42,0x7F,0x40,0x00}, // '1'
  {0x42,0x61,0x51,0x49,0x46}, // '2'
  {0x21,0x41,0x45,0x4B,0x31}, // '3'
  {0x18,0x14,0x12,0x7F,0x10}, // '4'
  {0x27,0x45,0x45,0x45,0x39}, // '5'
  {0x3C,0x4A,0x49,0x49,0x30}, // '6'
  {0x01,0x71,0x09,0x05,0x03}, // '7'
  {0x36,0x49,0x49,0x49,0x36}, // '8'
  {0x06,0x49,0x49,0x29,0x1E}, // '9'
  {0x7E,0x09,0x09,0x09,0x7E}, // 'A'
  {0x7F,0x49,0x49,0x49,0x36}, // 'B'
  {0x3E,0x41,0x41,0x41,0x22}, // 'C'
  {0x7F,0x41,0x41,0x22,0x1C}, // 'D'
  {0x7F,0x49,0x49,0x49,0x41}, // 'E'
  {0x7F,0x09,0x09,0x09,0x01}, // 'F'
  {0x3E,0x41,0x49,0x49,0x7A}, // 'G'
  {0x7F,0x08,0x08,0x08,0x7F}, // 'H'
  {0x00,0x41,0x7F,0x41,0x00}, // 'I'
  {0x20,0x40,0x41,0x3F,0x01}, // 'J'
  {0x7F,0x08,0x14,0x22,0x41}, // 'K'
  {0x7F,0x40,0x40,0x40,0x40}, // 'L'
  {0x7F,0x02,0x0C,0x02,0x7F}, // 'M'
  {0x7F,0x04,0x08,0x10,0x7F}, // 'N'
  {0x3E,0x41,0x41,0x41,0x3E}, // 'O'
  {0x7F,0x09,0x09,0x09,0x06}, // 'P'
  {0x3E,0x41,0x51,0x21,0x5E}, // 'Q'
  {0x7F,0x09,0x19,0x29,0x46}, // 'R'
  {0x46,0x49,0x49,0x49,0x31}, // 'S'
  {0x01,0x01,0x7F,0x01,0x01}, // 'T'
  {0x3F,0x40,0x40,0x40,0x3F}, // 'U'
  {0x1F,0x20,0x40,0x20,0x1F}, // 'V'
  {0x7F,0x20,0x18,0x20,0x7F}, // 'W'
  {0x63,0x14,0x08,0x14,0x63}, // 'X'
  {0x07,0x08,0x70,0x08,0x07}, // 'Y'
  {0x61,0x51,0x49,0x45,0x43},  // 'Z'
  {0x00,0x36,0x36,0x00,0x00}, // ':' index=37
  {0x00,0x60,0x60,0x00,0x00}, // '.' index=38
  {0x08,0x08,0x08,0x08,0x08}, // '-' index=39
  {0x04,0x0A,0x11,0x00,0x00}, // '^' index=40
  {0x00,0x11,0x0A,0x04,0x00}  // 'v' index=41
};

int8_t fontIndex(char c) {
  if (c == ' ') return 0;
  if (c >= '0' && c <= '9') return 1 + (c - '0');
  if (c >= 'A' && c <= 'Z') return 11 + (c - 'A');
  if (c >= 'a' && c <= 'z') return 11 + (c - 'a');
  if (c == ':') return 37;
  if (c == '.') return 38;
  if (c == '-') return 39;
  if (c == '^') return 40;
  if (c == 'v') return 41;
  return 0; // 
}

void oledWriteChar(char c) {
  int8_t idx = fontIndex(c);
  for (uint8_t i = 0; i < 5; i++) {
    uint8_t col = pgm_read_byte(&FONT5x7[idx][i]);
    oledSendData(col);
  }
  oledSendData(0x00);
}

void oledPrint(uint8_t xChar, uint8_t yPage, const char* s) {
  oledSetCursor(xChar, yPage);
  while (*s) {
    oledWriteChar(*s++);
  }
}

//TAN
void oledPrintFloat(uint8_t xChar, uint8_t yPage, float val, uint8_t digits){
  char buf[16];
  dtostrf(val, 0, digits, buf);
  oledPrint(xChar, yPage, buf);
}


void selfTestOLED() {
  oledClear();
  oledPrint(0, 1, "SELF TEST OK");
  oledPrint(0, 2, "TEMP AND PRESS");

  digitalWrite(greenLED, LOW);
  digitalWrite(yellowLED, LOW);
  digitalWrite(redLED, LOW);
  digitalWrite(pGreenLED, LOW);
  digitalWrite(pYellowLED, LOW);
  digitalWrite(pRedBuzzerLED, LOW);

  digitalWrite(yellowLED, HIGH);
  digitalWrite(pYellowLED, HIGH);
  delay(200);
  digitalWrite(yellowLED, LOW);
  digitalWrite(pYellowLED, LOW);
  delay(100);

  digitalWrite(greenLED, HIGH);
  digitalWrite(pGreenLED, HIGH);
  delay(200);
  digitalWrite(greenLED, LOW);
  digitalWrite(pGreenLED, LOW);
  delay(100);

  digitalWrite(redLED, HIGH);
  digitalWrite(pRedBuzzerLED, HIGH);
  delay(200);
  digitalWrite(redLED, LOW);
  digitalWrite(pRedBuzzerLED, LOW);
  delay(100);

  oledClear();
}
//KONG
// MPX4115 pressure reading (0.28V–1.13V output corresponds to 20–115 kPa)
float readPressure() {
  int raw = analogRead(pressurePin);

  float ratio = raw / 1023.0;

  // Datasheet formula:
  // Vout = Vs * (0.009 * P - 0.095)
  // => Vout/Vs = 0.009 * P - 0.095
  // => 0.009 * P = (Vout/Vs) + 0.095
  // => P_raw(kPa) = (ratio + 0.095) / 0.009
  float pressure_kPa = (ratio + 0.095) / 0.009;
  pressure_kPa -= 1.4f;
  if (pressure_kPa < 0) pressure_kPa = 0;
  return pressure_kPa;
}


//KONG
// ===== Button debounce detection: returns true when a press is newly detected =====
bool checkButton(int pin, bool &state, bool &lastReading, unsigned long &lastDebounceTime) {
  bool reading = digitalRead(pin);
  unsigned long now = millis();

  if (reading != lastReading) {
    lastDebounceTime = now;
    lastReading = reading;
  }

  if ((now - lastDebounceTime) > debounceDelay) {
    if (reading != state) {
      state = reading;
      if (state == LOW) {
        return true;
      }
    }
  }
  
  return false;
}

// ===== Draw main menu: display only, no state changes =====
void drawMainMenu() {
  oledClear();
  oledPrint(0, 0, "MAIN MENU");

  if (currentMenuIndex == 0) {
    oledPrint(0, 1, "SELECTED:HOME");
    oledPrint(0, 2, "         SETTINGS");
  } else {
    oledPrint(0, 1, "SELECTED:SETTING");
    oledPrint(0, 2, "         HOME   ");
  }

  oledPrint(0, 3, "D3:NEXT D4:ENTER");
}

//TAN
// ===== Draw settings screen =====
// Settings static content: drawn once when entering the page
void drawSettingsStatic() {
  oledClear();
  oledPrint(0, 0, "SETTINGS");
  oledPrint(0, 1, "TEMP UNIT: DEG C");
  oledPrint(0, 2, "PRESS UNIT: kPa");
}

// Settings dynamic content: only update the countdown line, no screen clear
void updateSettingsCountdown() {
  unsigned long elapsed = millis() - settingsEnterMs;
  int remainSec = (SETTINGS_TIMEOUT_MS - elapsed + 999) / 1000;
  if (remainSec < 0) remainSec = 0;

  char buf[17];
  snprintf(buf, sizeof(buf), "AUTO BACK:%2d", remainSec);

  oledPrint(0, 3, buf);
}

//KONG
// ===== Menu State Machine: switch currentScreen based on button input =====
void handleButtons() {
  bool upPressed   = checkButton(buttonUpPin,   buttonUpState,   lastButtonUpReading,   lastButtonUpDebounceTime);
  bool backPressed = checkButton(buttonBackPin, buttonBackState, lastButtonBackReading, lastButtonBackDebounceTime);

  if (currentScreen == SCREEN_MAIN_MENU) {
    // Main Menu: UP = move cursor, BACK = enter selected item
    if (upPressed) {
      currentMenuIndex = (currentMenuIndex == 0) ? 1 : 0;
      drawMainMenu();
    }

    if (backPressed) {
      if (currentMenuIndex == 0) {
        // Enter HOME: temperature / pressure monitoring screen
        currentScreen = SCREEN_HOME;
        oledClear();  // Clear first, HOME screen will be redrawn in loop()
      } else {
        // Enter SETTINGS
        currentScreen = SCREEN_SETTINGS;
        settingsEnterMs = millis();        // start auto-return countdown
        drawSettingsStatic();              // draw static content once
        updateSettingsCountdown();         // draw first countdown frame
      }
    }
  } else {
    // HOME or SETTINGS: BACK always returns to main menu
    if (backPressed) {
      currentScreen = SCREEN_MAIN_MENU;
      drawMainMenu();
    }
  }
}


//TAN
// ========== SETUP ==========
void setup () {
  peripheral_setup();

  // ===== Temperature system IO =====
  pinMode(greenLED, OUTPUT);
  pinMode(yellowLED, OUTPUT);
  pinMode(redLED, OUTPUT);
  pinMode(LM35, INPUT);
  pinMode(greenYellowBoundary, INPUT);
  pinMode(yellowRedBoundary, INPUT);
   
  // ===== OLED initialization & self-test =====
  oledInit();
  selfTestOLED();

//KONG
  // ===== Menu button initialization =====
  pinMode(buttonUpPin,   INPUT_PULLUP);
  pinMode(buttonBackPin, INPUT_PULLUP);

  // Enter main menu after power-up
  currentScreen    = SCREEN_MAIN_MENU;
  currentMenuIndex = 0;
  drawMainMenu();

  // ===== Pressure system IO =====
  pinMode(pGreenLED, OUTPUT);
  pinMode(pYellowLED, OUTPUT);
  pinMode(pRedBuzzerLED, OUTPUT);

  // Turn off all pressure indicators at startup
  digitalWrite(pGreenLED, LOW);
  digitalWrite(pYellowLED, LOW);
  digitalWrite(pRedBuzzerLED, LOW);

  // ===== Timer1 periodic interrupt configuration (50 ms) =====
  cli();              // disable global interrupt
  TCCR1A = 0;
  TCCR1B = 0;
  // 16 MHz / 64 = 250 kHz, 50 ms = 12500 counts → OCR1A = 12499
  OCR1A = 12499;
  TCCR1B |= (1 << WGM12);              // CTC mode
  TCCR1B |= (1 << CS11) | (1 << CS10); // prescaler = 64
  TIMSK1 |= (1 << OCIE1A);             // enable compare match interrupt
  sei();              // enable global interrupt

  // ===== Emergency hardware interrupt input =====
  pinMode(emergencyPin, INPUT_PULLUP);

  // LM393 DO output HIGH (over-pressure) → trigger RISING interrupt
  attachInterrupt(digitalPinToInterrupt(emergencyPin), emergencyISR, RISING);
}

void loop() {
  peripheral_loop();

  // ===== Emergency protection mode (highest priority) =====
  if (emergencyTriggered) {

    // Temperature LEDs: all ON
    digitalWrite(redLED, HIGH);
    digitalWrite(yellowLED, HIGH);
    digitalWrite(greenLED, HIGH);

    // Pressure LEDs + buzzer (D7): all ON
    digitalWrite(pRedBuzzerLED, HIGH);
    digitalWrite(pYellowLED, HIGH);
    digitalWrite(pGreenLED, HIGH);

    // OLED warning message (last line)
    oledPrint(0, 3, "!!! OVER PRESS !!!");

    // System locked until power reset
    return;
  }

  handleButtons();

  // ===== SETTINGS page: auto-return timeout & countdown refresh =====
  if (currentScreen == SCREEN_SETTINGS) {
    unsigned long nowS = millis();
    unsigned long elapsed = nowS - settingsEnterMs;

    // Timeout → return to main menu automatically
    if (elapsed >= SETTINGS_TIMEOUT_MS) {
      currentScreen = SCREEN_MAIN_MENU;
      drawMainMenu();
      return;
    }

    // Refresh countdown once per second (no screen clear)
    if (nowS - lastCountdownDrawMs >= 1000) {
      lastCountdownDrawMs = nowS;
      updateSettingsCountdown();
    }
  }

  // ===== HOME page: forced BACK handling =====
  if (currentScreen == SCREEN_HOME && digitalRead(buttonBackPin) == LOW) {
    currentScreen = SCREEN_MAIN_MENU;
    drawMainMenu();
    delay(200);   // prevent long-press retrigger
    return;       // skip HOME rendering this cycle
  }

  // ===== Temperature sampling & threshold reading =====
  currentTemperature = analogRead(LM35)*(5.00/1023.00)/0.03 - 0.5;
  setLowTemperature  = analogRead(greenYellowBoundary)*(5.0/1023.0)*30;
  setHighTemperature = analogRead(yellowRedBoundary)*(5.0/1023.0)*30;
   
  // Ensure low <= high
  if (setLowTemperature > setHighTemperature) {
    float t = setLowTemperature;
    setLowTemperature = setHighTemperature;
    setHighTemperature = t;
  }

  // ===== Temperature trend detection (low sensitivity + rate limit) =====
  static unsigned long lastTempTrendMs = 0;
  unsigned long nowTemp = millis();

  float diff = currentTemperature - lastTemperature;

  // Re-evaluate trend at most once every 200 ms
  if (nowTemp - lastTempTrendMs >= 200) {
    if (diff > 0.3)       trendStr = "UP";
    else if (diff < -0.3) trendStr = "DN";
    else                  trendStr = "ST";

    lastTempTrendMs = nowTemp;
    lastTemperature = currentTemperature;
  }

  bool inRedZone = (currentTemperature > setHighTemperature || currentTemperature <= 0.0);

  // ===== Temperature zone indication =====
  // Below low threshold → YELLOW
  if (currentTemperature < setLowTemperature && currentTemperature > 0.0){
    digitalWrite(redLED, LOW);
    digitalWrite(greenLED, LOW);
    digitalWrite(yellowLED, HIGH); 
  // Normal range → GREEN
  } else if (currentTemperature <= setHighTemperature && currentTemperature >= setLowTemperature){
    digitalWrite(redLED, LOW);
    digitalWrite(greenLED, HIGH);
    digitalWrite(yellowLED, LOW);
  // Above high threshold → RED
  } else {
    digitalWrite(redLED, HIGH);
    digitalWrite(yellowLED, LOW);
    digitalWrite(greenLED, LOW);  
  }

  // ===== Red zone alarm blinking control =====
  unsigned long now = millis();
  if (inRedZone) {
    if (now - lastBlinkMs >= 200) {
      alarmBlink = !alarmBlink;
      lastBlinkMs = now;
    }
  } else {
    alarmBlink = false;  // no blink outside red zone
  }


  // ===== OLED DISPLAY =====
  //TAN
  if (currentScreen == SCREEN_HOME) {

    // Line 1: Temperature + trend + alarm
    oledPrint(0, 0, "T:");

    // Temperature display: fixed width = 3 chars, right-aligned, no ghosting
    char tBuf[6];
    snprintf(tBuf, sizeof(tBuf), "%3d", (int)(currentTemperature + 0.5));
    oledPrint(2, 0, tBuf);

    // Clear possible leftover characters after temperature field
    oledPrint(5, 0, "   ");

    // Temperature trend display
    oledPrint(9, 0, trendStr);   // UP / DN / ST

    // Alarm area (unchanged logic)
    if (inRedZone && alarmBlink) {
      oledPrint(14, 0, "ALRM");
    } else {
      oledPrint(14, 0, "    ");
    }

    // Line 3: Threshold summary (Temp + Pressure)
    char line2[17];
    int LT = (int)(setLowTemperature + 0.5);
    int HT = (int)(setHighTemperature + 0.5);
    int LP = (int)(P_LOW_BAR + 0.5);
    float HP = P_HIGH_BAR;

    char hpBuf[6];             // Buffer for "xx.x"
    dtostrf(HP, 0, 1, hpBuf);  // 1 decimal place
    snprintf(line2, sizeof(line2), "T%d-%dP%d-%s", LT, HT, LP, hpBuf);
    oledPrint(0, 2, line2);

  //KONG
    // ===== OLED Line 2: Pressure display (kPa) =====
    oledPrint(0, 1, "P:");
    oledPrintFloat(2, 1, currentPressure, 1);  // e.g. 37.8
    oledPrint(7, 1, "  ");                     // clear tail

    oledPrint(9, 1, pTrendStr);                // UP / DN / ST

    // ===== OLED Line 4: System diagnostics (Temp × Pressure logic) =====
    const char* diag = "NORMAL";  // default state

    // Case 1: High temperature + low pressure
    if (currentTemperature > setHighTemperature && currentPressure < P_LOW_BAR) {
      diag = "BOOST PUMP";
    }
    // Case 2: High pressure + temperature in normal range
    else if (currentPressure > P_HIGH_BAR && 
             currentTemperature >= setLowTemperature &&
             currentTemperature <= setHighTemperature) {
      diag = "FLOW DOWN";
    }
    // Case 3: Low pressure + temperature rising
    else if (currentPressure < P_LOW_BAR && trendStr == "UP") {
      diag = "PROTECT STOP";
    }
    // Case 4: Temperature rising × pressure stable
    else if (trendStr == "UP" && pTrendStr == "ST") {
      diag = "LOAD ^";
    }
    // Case 5: Temperature stable × pressure rising
    else if (trendStr == "ST" && pTrendStr == "UP") {
      diag = "BLOCK?";
    }
    // Case 6: Temperature stable × pressure falling
    else if (trendStr == "ST" && pTrendStr == "DN") {
      diag = "LEAK?";
    }
    // Case 7: Sudden pressure drop (> 3 kPa)
    else if ((lastPressure - currentPressure) > 3.0) {
      diag = "PUMP FAIL?";
    }

    // ===== OLED diagnostics output =====
    char lineBuf[17];  // SSD1306: 6 px font → 16 chars per line
    snprintf(lineBuf, sizeof(lineBuf), "%-16s", diag);
    // %-16s pads spaces automatically, no manual clear required
    oledPrint(0, 3, lineBuf);

    // Bottom-right BACK hint overlay
    oledPrint(BACK_HINT_X, BACK_HINT_Y, "BACK");

  } // if (currentScreen == SCREEN_HOME)

  // ===== End of OLED display =====



  //KONG
  // ========= Pressure check: triggered by timer interrupt =========
  if (pressureCheckFlag) {
    pressureCheckFlag = false;   // clear flag

    // 1. Read current pressure
    currentPressure = readPressure();

    // 2. Pressure trend detection (low sensitivity + rate limit)
    static unsigned long lastPressTrendMs = 0;
    unsigned long nowPress = millis();

    float pdiff = currentPressure - lastPressure;

    if (nowPress - lastPressTrendMs >= 200) {  // evaluate at most every 200 ms
      if (pdiff > 0.1)         pTrendStr = "UP";
      else if (pdiff < -0.1)   pTrendStr = "DN";
      else                     pTrendStr = "ST";

      lastPressTrendMs = nowPress;
      lastPressure     = currentPressure;
    }

    // 3. Pressure indicator logic (same pattern as temperature)
    if (currentPressure < P_LOW_BAR) {
      // Low pressure: YELLOW
      digitalWrite(pYellowLED, HIGH);
      digitalWrite(pGreenLED, LOW);
      digitalWrite(pRedBuzzerLED, LOW);
    } else if (currentPressure <= P_HIGH_BAR) {
      // Normal range: GREEN
      digitalWrite(pYellowLED, LOW);
      digitalWrite(pGreenLED, HIGH);
      digitalWrite(pRedBuzzerLED, LOW);
    } else {
      // High pressure: RED + buzzer
      digitalWrite(pGreenLED, LOW);
      digitalWrite(pYellowLED, LOW);
      digitalWrite(pRedBuzzerLED, HIGH);   // red only (Proteus LED behavior noted)
      // tone() not used, so no noTone() required
    }

    // 4. Optional OLED debug output (reserved for future refinement)
    // Example:
    // P:1.23B UP
    // oledPrint(0, 2, "P:");
    // oledPrintFloat(2, 2, currentPressure, 2);
    // oledPrint(9, 2, pTrendStr);
  }



}

//KONG interrupt
// Timer1 compare match ISR: triggered every 50 ms
ISR(TIMER1_COMPA_vect) {
  pressureCheckFlag = true;   // set flag only, real processing in loop()
}

// ===== External interrupt ISR =====
void emergencyISR() {
  emergencyTriggered = true;
}



#pragma GCC pop_options
